/*
 * Copyright (c) 2013-2015 The btcsuite developers
 * Copyright (c) 2015 The Decred developers
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package wallet

import (
	"fmt"
	"sync"

	"github.com/decred/dcrutil"
	"github.com/decred/dcrwallet/waddrmgr"
)

// addressPoolBuffer is the number of addresses to fetch when the address pool
// runs out of new addresses to use.
const addressPoolBuffer = 20

// addressPool is a cache of addresses to use that are generated by the
// address manager. It is safe than directly calling the address manager
// because doing that will increment the cursor of the extended key even
// if the created transaction errors out in some way.
type addressPool struct {
	// Represent addresses as strings because the address interface
	// doesn't have any good way to make comparisons.
	addresses []string
	cursor    int
	account   uint32
	branch    uint32
	index     uint32
	started   bool
	mutex     sync.Mutex
	wallet    *Wallet
}

// NewAddressPool creates a new address pool for the wallet default account.
func NewAddressPool() *addressPool {
	return &addressPool{
		started: false,
	}
}

// initialize initializes an address pool for the passed account and branch
// to the address index given.
func (a *addressPool) initialize(account uint32, branch uint32, index uint32,
	w *Wallet) error {
	a.mutex.Lock()
	defer a.mutex.Unlock()

	// Do not reinitialize an address pool that was already started.
	// This can happen if the RPC client dies due to a disconnect
	// from the daemon.
	if a.started {
		return nil
	}

	// 0 and 1 refer to the external and internal branches of the wallet.
	// Other branches are so far unused.
	if branch > waddrmgr.InternalBranch {
		return fmt.Errorf("unknown branch %v given when attempting to "+
			"initialize address pool for account %v", branch, account)
	}

	a.addresses = make([]string, 0)
	a.wallet = w
	a.account = account
	a.branch = branch
	a.index = index

	log.Debugf("Address pool initialized to next addr index %v on pool "+
		"branch %v", a.index, branch)

	a.cursor = 0
	a.started = true

	return nil
}

// GetNewAddress must be run as many times as necessary with the address pool
// mutex locked. Each time, it returns a single new address while adding that
// address to the toDelete map. If the address pool runs out of addresses, it
// generates more from the address manager.
func (a *addressPool) GetNewAddress() (dcrutil.Address, error) {
	if !a.started {
		return nil, fmt.Errorf("failed to GetNewAddress; pool not started")
	}

	chainClient, err := a.wallet.requireChainClient()
	if err != nil {
		return nil, err
	}

	// Replenish the pool if we're at the last address.
	if a.cursor == len(a.addresses)-1 || len(a.addresses) == 0 {
		var nextAddrFunc func(uint32, uint32) ([]waddrmgr.ManagedAddress, error)
		switch a.branch {
		case waddrmgr.InternalBranch:
			nextAddrFunc = a.wallet.Manager.NextInternalAddresses
		case waddrmgr.ExternalBranch:
			nextAddrFunc = a.wallet.Manager.NextExternalAddresses
		default:
			return nil, fmt.Errorf("unknown default account branch %v", a.branch)
		}

		addrs, err :=
			nextAddrFunc(a.account, addressPoolBuffer)
		if err != nil {
			return nil, err
		}

		for _, addr := range addrs {
			a.addresses = append(a.addresses, addr.Address().EncodeAddress())
		}
	}

	// As these are all encoded addresses, we should never throw an error
	// converting back.
	curAddressStr := a.addresses[a.cursor]
	curAddress, _ := dcrutil.DecodeAddress(curAddressStr, a.wallet.chainParams)
	a.cursor++
	a.index++

	log.Debugf("Get new address for branch %v returned %s (idx %v) from "+
		"the address pool", a.branch, curAddressStr, a.index)

	// Add the address to the notifications watcher.
	addrs := make([]dcrutil.Address, 1)
	addrs[0] = curAddress
	if err := chainClient.NotifyReceived(addrs); err != nil {
		return nil, err
	}

	return curAddress, nil
}

// BatchFinish must be run after every successful series of usages of
// GetNewAddress to purge the addresses from the unused map.
func (a *addressPool) BatchFinish() {
	log.Debugf("Closing address batch for pool branch %v, next index %v",
		a.branch, a.index+1)

	isInternal := a.branch == waddrmgr.InternalBranch
	err := a.wallet.Manager.StoreNextToUseAddress(isInternal, a.account,
		a.index)
	if err != nil {
		log.Errorf("Failed to store next to use address idx for "+
			"pool branch %v, account %v in the manager on batch "+
			"finish: %v", a.branch, a.account, err.Error())
	}

	// We used all the addresses, so we need to pull new addresses
	// on the next call of this function.
	if a.cursor >= len(a.addresses) {
		a.addresses = nil
		a.cursor = 0
		return
	}

	a.addresses = a.addresses[a.cursor:len(a.addresses)]
	a.cursor = 0
}

// BatchRollback must be run after every unsuccessful series of usages
// of GetNewAddress to restore the cursor to the original position in
// the slice, thus marking all addresses unused again.
func (a *addressPool) BatchRollback() {
	a.index -= uint32(a.cursor)
	a.cursor = 0
}

// Close writes the next to use index for the address pool to disk, then sets
// the address pool as closed.
func (a *addressPool) Close() error {
	a.mutex.Lock()
	defer a.mutex.Unlock()

	if !a.started {
		return fmt.Errorf("attempted to close uninitialized address pool")
	}

	isInternal := a.branch == waddrmgr.InternalBranch
	err := a.wallet.Manager.StoreNextToUseAddress(isInternal, a.account,
		a.index)
	if err != nil {
		return fmt.Errorf("Failed to store next to use address idx for "+
			"pool branch %v, account %v in the manager on address "+
			"pool close: %v", a.branch, a.account, err.Error())
	}

	a.started = false
	return nil
}

// CloseAddressPools grabs one last new address for both internal and external
// acounts. Then it inserts them into the address manager database, so that
// the address manager can be used upon startup to restore the cursor position
// in the address pool.
func (w *Wallet) CloseAddressPools() {
	if w.internalPool == nil {
		return
	}
	if w.externalPool == nil {
		return
	}
	if !w.internalPool.started || !w.externalPool.started {
		return
	}

	err := w.internalPool.Close()
	if err != nil {
		log.Errorf("failed to close default acct internal addr pool: %v",
			err)
	}
	err = w.externalPool.Close()
	if err != nil {
		log.Errorf("failed to close default acct external addr pool: %v",
			err)
	}

	return
}

// GetNewAddressExternal is the exported function that gets a new external address
// for the default account from the external address mempool.
func (w *Wallet) GetNewAddressExternal() (dcrutil.Address, error) {
	w.externalPool.mutex.Lock()
	defer w.externalPool.mutex.Unlock()
	address, err := w.externalPool.GetNewAddress()
	if err == nil {
		w.externalPool.BatchFinish()
	}
	return address, err
}

// GetNewAddressInternal is the exported function that gets a new internal address
// for the default account from the internal address mempool.
func (w *Wallet) GetNewAddressInternal() (dcrutil.Address, error) {
	w.internalPool.mutex.Lock()
	defer w.internalPool.mutex.Unlock()
	address, err := w.internalPool.GetNewAddress()
	if err == nil {
		w.internalPool.BatchFinish()
	}
	return address, err
}

// NewAddress returns the next external chained address for a wallet given some
// account.
func (w *Wallet) NewAddress(account uint32) (dcrutil.Address, error) {
	// Get next address from wallet.
	addrs, err := w.Manager.NextExternalAddresses(account, 1)
	if err != nil {
		return nil, err
	}

	// Request updates from dcrd for new transactions sent to this address.
	utilAddrs := make([]dcrutil.Address, len(addrs))
	for i, addr := range addrs {
		utilAddrs[i] = addr.Address()
	}
	w.chainClientLock.Lock()
	chainClient := w.chainClient
	w.chainClientLock.Unlock()
	if chainClient != nil {
		err := chainClient.NotifyReceived(utilAddrs)
		if err != nil {
			return nil, err
		}
	}

	props, err := w.Manager.AccountProperties(account)
	if err != nil {
		log.Errorf("Cannot fetch account properties for notification "+
			"after deriving next external address: %v", err)
	} else {
		w.NtfnServer.notifyAccountProperties(props)
	}

	return utilAddrs[0], nil
}

// NewChangeAddress returns a new change address for a wallet.
func (w *Wallet) NewChangeAddress(account uint32) (dcrutil.Address, error) {
	// Get next chained change address from wallet for account.
	addrs, err := w.Manager.NextInternalAddresses(account, 1)
	if err != nil {
		return nil, err
	}

	// Request updates from dcrd for new transactions sent to this address.
	utilAddrs := make([]dcrutil.Address, len(addrs))
	for i, addr := range addrs {
		utilAddrs[i] = addr.Address()
	}

	chainClient, err := w.requireChainClient()
	if err == nil {
		err = chainClient.NotifyReceived(utilAddrs)
		if err != nil {
			return nil, err
		}
	}

	return utilAddrs[0], nil
}

// ReusedAddress returns an address that is reused from the external
// branch of the wallet, to cut down on new address usage for wallets.
// Should be used judiciously.
func (w *Wallet) ReusedAddress() (dcrutil.Address, error) {
	addr, err := w.Manager.GetAddress(0, waddrmgr.DefaultAccountNum,
		waddrmgr.ExternalBranch)
	if err != nil {
		return nil, err
	}

	return addr, err
}
